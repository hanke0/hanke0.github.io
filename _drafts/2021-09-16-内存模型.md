---
layout: post
title: "MESI, volatile, cas, mutex 关系分不清楚？带你探索内存模型的秘密"
description: ""
tags: mutex
comments: true
---

最近看了一些问题，比如说
- 既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？
- 如何理解 C++11 的六种 memory order？

为了解答这些问题，需要从缓存一致性和内存一致性开始讲起，接着是 cas 操作，最后是锁的实现，系统
理解了这一套知识，之后遇到这些问题就不会疑惑了。

## 1. 缓存一致性和内存一致性

缓存一致性(Cache coherence) 解决的问题是共享资源和本地缓存的一致性，在我们的语境下面主要是指
多核系统中保证 CPU 缓存和内存是一致的。缓存一致性保证的是缓存不会影响的程序运行的正确性，主要
保证的读出来的内容一定是写操作后之后的内容，不会出现读到写操作之前的内容。我们熟知的 MESI 协议
就是缓存一致性协议。缓存一致性保证了写之后的内容是读可见的，

内存一致性(Memory consistency) 讨论的问题是对内容读和写的顺序，相同或者不同位置的内存
读(load)和内存写(store)在现在 CPU 上面是难以预测的，内存一致性保证了无论是单核还是多核，内存
的读写顺序能够按照开发的意愿排序。
内存模型（Memory Model）[^memory_model]描述了计算机内存，C++ 11 提出的
6 种 memory order，提出了一个线程读取内存时候，它可能见到的几种结果，1. 初始值，2. 相同线程
上一次写的值，3. 不同线程写的值，这 6 种 memory order 对相同或者不同线程对内存的读写的顺序做
了强规定。

经常有人在混淆缓存一致性和内存一致性的问题，其实它们两个区别很大的，一个讨论是的缓存和内存是一样
的，一个讨论的是对内存的读写顺序。
很多人在讨论锁的提及缓存一致性和内存一致性喜欢提 CPU 三级缓存和乱序执行，

volatile 在 C/C++ 只是对编译器的规定，他要求编译器每一次访问这个变量时候都从持久存储器中读取，
不允许对这里的读取做优化。所以在 C/C++ 里面，

[^memory_model]: [Learn the architecture: AArch64 memory model](https://developer.arm.com/documentation/102376/latest){:target="_blank"}
